import type { Accessibility, Argument, ArrayExpression, ArrayPattern, ArrowFunctionExpression, AssignmentExpression, AssignmentOperator, AssignmentPattern, AssignmentPatternProperty, AssignmentProperty, AwaitExpression, BigIntLiteral, BinaryExpression, BinaryOperator, BlockStatement, BooleanLiteral, BreakStatement, CallExpression, CatchClause, ClassDeclaration, ClassExpression, ClassMember, ClassMethod, ClassProperty, ComputedPropName, ConditionalExpression, Constructor, ContinueStatement, DebuggerStatement, Declaration, Decorator, DefaultDecl, DoWhileStatement, EmptyStatement, ExportAllDeclaration, ExportDeclaration, ExportDefaultDeclaration, ExportDefaultExpression, ExportDefaultSpecifier, ExportNamedDeclaration, ExportNamespaceSpecifier, ExportSpecifier, ExprOrSpread, Expression, ExpressionStatement, Fn, ForInStatement, ForOfStatement, ForStatement, FunctionDeclaration, FunctionExpression, GetterProperty, Identifier, IfStatement, Import, ImportDeclaration, ImportDefaultSpecifier, ImportNamespaceSpecifier, ImportSpecifier, JSXAttrValue, JSXAttribute, JSXAttributeName, JSXAttributeOrSpread, JSXClosingElement, JSXClosingFragment, JSXElement, JSXElementChild, JSXElementName, JSXEmptyExpression, JSXExpression, JSXExpressionContainer, JSXFragment, JSXMemberExpression, JSXNamespacedName, JSXObject, JSXOpeningElement, JSXOpeningFragment, JSXSpreadChild, JSXText, KeyValuePatternProperty, KeyValueProperty, LabeledStatement, MemberExpression, MetaProperty, MethodKind, MethodProperty, Module, ModuleExportName, ModuleItem, NamedExportSpecifier, NewExpression, NullLiteral, NumericLiteral, ObjectExpression, ObjectPattern, ObjectPatternProperty, OptionalChainingCall, OptionalChainingExpression, Param, ParenthesisExpression, Pattern, PrivateMethod, PrivateName, PrivateProperty, Property, PropertyName, RegExpLiteral, RestElement, ReturnStatement, Script, SequenceExpression, SetterProperty, Span, SpreadElement, Statement, StaticBlock, StringLiteral, Super, SuperPropExpression, SwitchCase, SwitchStatement, TaggedTemplateExpression, TemplateElement, TemplateLiteral, ThisExpression, ThrowStatement, TruePlusMinus, TryStatement, TsArrayType, TsAsExpression, TsCallSignatureDeclaration, TsConditionalType, TsConstAssertion, TsConstructSignatureDeclaration, TsConstructorType, TsEntityName, TsEnumDeclaration, TsEnumMember, TsEnumMemberId, TsExportAssignment, TsExpressionWithTypeArguments, TsExternalModuleReference, TsFnParameter, TsFunctionType, TsGetterSignature, TsImportEqualsDeclaration, TsImportType, TsIndexSignature, TsIndexedAccessType, TsInferType, TsInstantiation, TsInterfaceBody, TsInterfaceDeclaration, TsIntersectionType, TsKeywordType, TsKeywordTypeKind, TsLiteral, TsLiteralType, TsMappedType, TsMethodSignature, TsModuleBlock, TsModuleDeclaration, TsModuleName, TsModuleReference, TsNamespaceBody, TsNamespaceDeclaration, TsNamespaceExportDeclaration, TsNonNullExpression, TsOptionalType, TsParameterProperty, TsParameterPropertyParameter, TsParenthesizedType, TsPropertySignature, TsQualifiedName, TsRestType, TsSetterSignature, TsTemplateLiteralType, TsThisType, TsThisTypeOrIdent, TsTupleElement, TsTupleType, TsType, TsTypeAliasDeclaration, TsTypeAnnotation, TsTypeAssertion, TsTypeElement, TsTypeLiteral, TsTypeOperator, TsTypeOperatorOp, TsTypeParameter, TsTypeParameterDeclaration, TsTypeParameterInstantiation, TsTypePredicate, TsTypeQuery, TsTypeQueryExpr, TsTypeReference, TsUnionType, UnaryExpression, UnaryOperator, UpdateExpression, UpdateOperator, VariableDeclaration, VariableDeclarationKind, VariableDeclarator, WhileStatement, WithStatement, YieldExpression } from "@swc/core";
export declare const createIdentifier: (value: string, optional?: boolean) => Identifier;
export declare const createStringLiteral: (value: string, raw?: string) => StringLiteral;
export declare const createNumericLiteral: (value: number, raw?: string) => NumericLiteral;
export declare const createBigIntLiteral: (value: bigint, raw?: string) => BigIntLiteral;
export declare const createBooleanLiteral: (value: boolean) => BooleanLiteral;
export declare const createNullLiteral: () => NullLiteral;
export declare const createRegExpLiteral: (pattern: string, flags: string) => RegExpLiteral;
export declare const createArgument: (expression: Expression, spread?: boolean) => Argument;
export declare const createCallExpression: (callee: Expression | Super | Import, args?: Argument[], typeArguments?: TsTypeParameterInstantiation) => CallExpression;
export declare const createClassProperty: (key: PropertyName, value?: Expression, accessibility?: Accessibility, typeAnnotation?: TsTypeAnnotation, decorators?: Decorator[], declare?: boolean, definite?: boolean, isAbstract?: boolean, isOptional?: boolean, isOverride?: boolean, isStatic?: boolean, readonly?: boolean) => ClassProperty;
export declare const createPrivateProperty: (key: PrivateName, value?: Expression, accessibility?: Accessibility, typeAnnotation?: TsTypeAnnotation, decorators?: Decorator[], definite?: boolean, isOptional?: boolean, isOverride?: boolean, isStatic?: boolean, readonly?: boolean) => PrivateProperty;
export declare const createParam: (pat: Pattern, decorators?: Decorator[]) => Param;
export declare const createConstructor: (key: PropertyName, params: (TsParameterProperty | Param)[], body?: BlockStatement, accessibility?: Accessibility, isOptional?: boolean) => Constructor;
export declare const createClassMethod: (kind: MethodKind, key: PropertyName, fn: Fn, accessibility?: Accessibility, isAbstract?: boolean, isOptional?: boolean, isOverride?: boolean, isStatic?: boolean) => ClassMethod;
export declare const createPrivateMethod: (kind: MethodKind, key: PrivateName, fn: Fn, accessibility?: Accessibility, isAbstract?: boolean, isOptional?: boolean, isOverride?: boolean, isStatic?: boolean) => PrivateMethod;
export declare const createStaticBlock: (body: BlockStatement) => StaticBlock;
export declare const createDecorator: (expression: Expression) => Decorator;
export declare const createFunctionDeclaration: (identifier: Identifier, params: Param[], body?: BlockStatement, typeParameters?: TsTypeParameterDeclaration, returnType?: TsTypeAnnotation, decorators?: Decorator[], declare?: boolean, async?: boolean, generator?: boolean) => FunctionDeclaration;
export declare const createClassDeclaration: (identifier: Identifier, body: ClassMember[], impls: TsExpressionWithTypeArguments[], superClass?: Expression, typeParams?: TsTypeParameterDeclaration, superTypeParams?: TsTypeParameterInstantiation, decorators?: Decorator[], declare?: boolean, isAbstract?: boolean) => ClassDeclaration;
export declare const createVariableDeclaration: (kind: VariableDeclarationKind, declare: boolean, declarations: VariableDeclarator[]) => VariableDeclaration;
export declare const createVariableDeclarator: (id: Pattern, definite: boolean, init?: Expression) => VariableDeclarator;
export declare const createOptionalChainingExpression: (base: MemberExpression | OptionalChainingCall, questionDotToken: Span) => OptionalChainingExpression;
export declare const createOptionalChainingCall: (callee: Expression, args?: ExprOrSpread[], typeArguments?: TsTypeParameterInstantiation) => OptionalChainingCall;
export declare const createThisExpression: () => ThisExpression;
export declare const createArrayExpression: (elements: (ExprOrSpread | undefined)[]) => ArrayExpression;
export declare const createExprOrSpread: (expression: Expression, spread?: Span) => ExprOrSpread;
export declare const createObjectExpression: (properties: (SpreadElement | Property)[]) => ObjectExpression;
export declare const createSpreadElement: (args: Expression, spread: Span) => SpreadElement;
export declare const createUnaryExpression: (operator: UnaryOperator, argument: Expression) => UnaryExpression;
export declare const createUpdateExpression: (operator: UpdateOperator, argument: Expression, prefix?: boolean) => UpdateExpression;
export declare const createBinaryExpression: (left: Expression, operator: BinaryOperator, right: Expression) => BinaryExpression;
export declare const createFunctionExpression: (params: Param[], body?: BlockStatement, identifier?: Identifier, typeParameters?: TsTypeParameterDeclaration, returnType?: TsTypeAnnotation, decorators?: Decorator[], async?: boolean, generator?: boolean) => FunctionExpression;
export declare const createClassExpression: (body: ClassMember[], impls?: TsExpressionWithTypeArguments[], superClass?: Expression, identifier?: Identifier, typeParams?: TsTypeParameterDeclaration, superTypeParams?: TsTypeParameterInstantiation, decorators?: Decorator[], isAbstract?: boolean) => ClassExpression;
export declare const createAssignmentExpression: (left: Expression | Pattern, operator: AssignmentOperator, right: Expression) => AssignmentExpression;
export declare const createMemberExpression: (object: Expression, property: Identifier | PrivateName | ComputedPropName) => MemberExpression;
export declare const createSuperPropExpression: (obj: Super, property: Identifier | ComputedPropName) => SuperPropExpression;
export declare const createConditionalExpression: (test: Expression, consequent: Expression, alternate: Expression) => ConditionalExpression;
export declare const createSuper: () => Super;
export declare const createImport: () => Import;
export declare const createNewExpression: (callee: Expression, args?: Argument[], typeArguments?: TsTypeParameterInstantiation) => NewExpression;
export declare const createSequenceExpression: (expressions: Expression[]) => SequenceExpression;
export declare const createArrowFunctionExpression: (params: Pattern[], body: BlockStatement | Expression, async?: boolean, generator?: boolean, typeParameters?: TsTypeParameterDeclaration, returnType?: TsTypeAnnotation) => ArrowFunctionExpression;
export declare const createYieldExpression: (argument?: Expression, delegate?: boolean) => YieldExpression;
export declare const createMetaProperty: (kind: "new.target" | "import.meta") => MetaProperty;
export declare const createAwaitExpression: (argument: Expression) => AwaitExpression;
export declare const createTemplateLiteral: (expressions?: Expression[], quasis?: TemplateElement[]) => TemplateLiteral;
export declare const createTaggedTemplateExpression: (tag: Expression, template: TemplateLiteral, typeParameters?: TsTypeParameterInstantiation) => TaggedTemplateExpression;
export declare const createTemplateElement: (raw: string, cooked?: string, tail?: boolean) => TemplateElement;
export declare const createParenthesisExpression: (expression: Expression) => ParenthesisExpression;
export declare const createPrivateName: (id: Identifier) => PrivateName;
export declare const createJSXMemberExpression: (object: JSXObject, property: Identifier) => JSXMemberExpression;
export declare const createJSXNamespacedName: (namespace: Identifier, name: Identifier) => JSXNamespacedName;
export declare const createJSXEmptyExpression: () => JSXEmptyExpression;
export declare const createJSXExpressionContainer: (expression: JSXExpression) => JSXExpressionContainer;
export declare const createJSXSpreadChild: (expression: Expression) => JSXSpreadChild;
export declare const createJSXOpeningElement: (name: JSXElementName, attributes: JSXAttributeOrSpread[], selfClosing?: boolean, typeArguments?: TsTypeParameterInstantiation) => JSXOpeningElement;
export declare const createJSXClosingElement: (name: JSXElementName) => JSXClosingElement;
export declare const createJSXAttribute: (name: JSXAttributeName, value?: JSXAttrValue) => JSXAttribute;
export declare const createJSXText: (value: string, raw?: string) => JSXText;
export declare const createJSXElement: (opening: JSXOpeningElement, children?: JSXElementChild[], closing?: JSXClosingElement) => JSXElement;
export declare const createJSXFragment: (opening: JSXOpeningFragment, children: JSXElementChild[] | undefined, closing: JSXClosingFragment) => JSXFragment;
export declare const createJSXOpeningFragment: () => JSXOpeningFragment;
export declare const createJSXClosingFragment: () => JSXClosingFragment;
export declare const createExportDefaultExpression: (expression: Expression) => ExportDefaultExpression;
export declare const createExportDeclaration: (declaration: Declaration) => ExportDeclaration;
export declare const createImportDeclaration: (specifiers: ImportSpecifier[], source: StringLiteral, typeOnly?: boolean, asserts?: ObjectExpression) => ImportDeclaration;
export declare const createExportAllDeclaration: (source: StringLiteral, asserts?: ObjectExpression) => ExportAllDeclaration;
export declare const createExportNamedDeclaration: (specifiers: ExportSpecifier[], source?: StringLiteral, asserts?: ObjectExpression, typeOnly?: boolean) => ExportNamedDeclaration;
export declare const createExportDefaultDeclaration: (decl: DefaultDecl) => ExportDefaultDeclaration;
export declare const createImportDefaultSpecifier: (local: Identifier) => ImportDefaultSpecifier;
export declare const createImportNamespaceSpecifier: (local: Identifier) => ImportNamespaceSpecifier;
export declare const createNamedImportSpecifier: (local: Identifier, imported?: ModuleExportName, isTypeOnly?: boolean) => ImportSpecifier;
export declare const createExportNamespaceSpecifier: (name: ModuleExportName) => ExportNamespaceSpecifier;
export declare const createExportDefaultSpecifier: (exported: Identifier) => ExportDefaultSpecifier;
export declare const createNamedExportSpecifier: (orig: ModuleExportName, exported?: ModuleExportName, isTypeOnly?: boolean) => NamedExportSpecifier;
export declare const createModule: (body?: ModuleItem[], interpreter?: string) => Module;
export declare const createScript: (body?: Statement[], interpreter?: string) => Script;
export declare const createArrayPattern: (elements: (Pattern | undefined)[], optional?: boolean, typeAnnotation?: TsTypeAnnotation) => ArrayPattern;
export declare const createObjectPattern: (properties: ObjectPatternProperty[], optional?: boolean, typeAnnotation?: TsTypeAnnotation) => ObjectPattern;
export declare const createAssignmentPattern: (left: Pattern, right: Expression, typeAnnotation?: TsTypeAnnotation) => AssignmentPattern;
export declare const createRestElement: (argument: Pattern, rest: Span, typeAnnotation?: TsTypeAnnotation) => RestElement;
export declare const createKeyValuePatternProperty: (key: PropertyName, value: Pattern) => KeyValuePatternProperty;
export declare const createAssignmentPatternProperty: (key: Identifier, value?: Expression) => AssignmentPatternProperty;
export declare const createKeyValueProperty: (key: PropertyName, value: Expression) => KeyValueProperty;
export declare const createAssignmentProperty: (key: Identifier, value: Expression) => AssignmentProperty;
export declare const createGetterProperty: (key: PropertyName, body?: BlockStatement, typeAnnotation?: TsTypeAnnotation) => GetterProperty;
export declare const createSetterProperty: (key: PropertyName, param: Pattern, body?: BlockStatement) => SetterProperty;
export declare const createMethodProperty: (key: PropertyName, params: Param[], body?: BlockStatement, async?: boolean, generator?: boolean, decorators?: Decorator[], typeParameters?: TsTypeParameterDeclaration, returnType?: TsTypeAnnotation) => MethodProperty;
export declare const createComputedPropName: (expression: Expression) => ComputedPropName;
export declare const createBlockStatement: (stmts?: Statement[]) => BlockStatement;
export declare const createExpressionStatement: (expression: Expression) => ExpressionStatement;
export declare const createEmptyStatement: () => EmptyStatement;
export declare const createDebuggerStatement: () => DebuggerStatement;
export declare const createWithStatement: (object: Expression, body: Statement) => WithStatement;
export declare const createReturnStatement: (argument?: Expression) => ReturnStatement;
export declare const createLabeledStatement: (label: Identifier, body: Statement) => LabeledStatement;
export declare const createBreakStatement: (label?: Identifier) => BreakStatement;
export declare const createContinueStatement: (label?: Identifier) => ContinueStatement;
export declare const createIfStatement: (test: Expression, consequent: Statement, alternate?: Statement) => IfStatement;
export declare const createSwitchStatement: (discriminant: Expression, cases?: SwitchCase[]) => SwitchStatement;
export declare const createThrowStatement: (argument: Expression) => ThrowStatement;
export declare const createTryStatement: (block: BlockStatement, handler?: CatchClause, finalizer?: BlockStatement) => TryStatement;
export declare const createWhileStatement: (test: Expression, body: Statement) => WhileStatement;
export declare const createDoWhileStatement: (test: Expression, body: Statement) => DoWhileStatement;
export declare const createForStatement: (body: Statement, init?: VariableDeclaration | Expression, test?: Expression, update?: Expression) => ForStatement;
export declare const createForInStatement: (left: VariableDeclaration | Pattern, right: Expression, body: Statement) => ForInStatement;
export declare const createForOfStatement: (left: VariableDeclaration | Pattern, right: Expression, body: Statement, _await?: Span) => ForOfStatement;
export declare const createSwitchCase: (test?: Expression, consequent?: Statement[]) => SwitchCase;
export declare const createCatchClause: (body: BlockStatement, param?: Pattern) => CatchClause;
export declare const createTsTypeAnnotation: (typeAnnotation: TsType) => TsTypeAnnotation;
export declare const createTsTypeParameterDeclaration: (parameters?: TsTypeParameter[]) => TsTypeParameterDeclaration;
export declare const createTsTypeParameter: (name: Identifier, _in: boolean, _out: boolean, constraint?: TsType, _default?: TsType) => TsTypeParameter;
export declare const createTsTypeParameterInstantiation: (params?: TsType[]) => TsTypeParameterInstantiation;
export declare const createTsParameterProperty: (param: TsParameterPropertyParameter, accessibility?: Accessibility, decorators?: Decorator[], override?: boolean, readonly?: boolean) => TsParameterProperty;
export declare const createTsQualifiedName: (left: TsEntityName, right: Identifier) => TsQualifiedName;
export declare const createTsCallSignatureDeclaration: (params: TsFnParameter[], typeAnnotation?: TsTypeAnnotation, typeParams?: TsTypeParameterDeclaration) => TsCallSignatureDeclaration;
export declare const createTsConstructSignatureDeclaration: (params?: TsFnParameter[], typeAnnotation?: TsTypeAnnotation, typeParams?: TsTypeParameterDeclaration) => TsConstructSignatureDeclaration;
export declare const createTsPropertySignature: (key: Expression, params: TsFnParameter[], init?: Expression, typeAnnotation?: TsTypeAnnotation, typeParams?: TsTypeParameterDeclaration, computed?: boolean, optional?: boolean, readonly?: boolean) => TsPropertySignature;
export declare const createTsGetterSignature: (key: Expression, typeAnnotation?: TsTypeAnnotation, computed?: boolean, optional?: boolean, readonly?: boolean) => TsGetterSignature;
export declare const createTsSetterSignature: (key: Expression, param: TsFnParameter, computed?: boolean, optional?: boolean, readonly?: boolean) => TsSetterSignature;
export declare const createTsMethodSignature: (key: Expression, params: TsFnParameter[], typeAnn?: TsTypeAnnotation, typeParams?: TsTypeParameterDeclaration, computed?: boolean, optional?: boolean, readonly?: boolean) => TsMethodSignature;
export declare const createTsIndexSignature: (params: TsFnParameter[], typeAnnotation?: TsTypeAnnotation, readonly?: boolean, isStatic?: boolean) => TsIndexSignature;
export declare const createTsKeywordType: (kind: TsKeywordTypeKind) => TsKeywordType;
export declare const createTsThisType: () => TsThisType;
export declare const createTsFunctionType: (params: TsFnParameter[], typeAnnotation: TsTypeAnnotation, typeParams?: TsTypeParameterDeclaration) => TsFunctionType;
export declare const createTsConstructorType: (params: TsFnParameter[], typeAnnotation: TsTypeAnnotation, typeParams?: TsTypeParameterDeclaration, isAbstract?: boolean) => TsConstructorType;
export declare const createTsTypeReference: (typeName: TsEntityName, typeParams?: TsTypeParameterInstantiation) => TsTypeReference;
export declare const createTsTypePredicate: (paramName: TsThisTypeOrIdent, asserts?: boolean, typeAnnotation?: TsTypeAnnotation) => TsTypePredicate;
export declare const createTsImportType: (argument: StringLiteral, qualifier?: TsEntityName, typeArguments?: TsTypeParameterInstantiation) => TsImportType;
export declare const createTsTypeQuery: (exprName: TsTypeQueryExpr, typeArguments?: TsTypeParameterInstantiation) => TsTypeQuery;
export declare const createTsTypeLiteral: (members?: TsTypeElement[]) => TsTypeLiteral;
export declare const createTsArrayType: (elemType: TsType) => TsArrayType;
export declare const createTsTupleType: (elemTypes?: TsTupleElement[]) => TsTupleType;
export declare const createTsTupleElement: (ty: TsType, label?: Pattern) => TsTupleElement;
export declare const createTsOptionalType: (typeAnnotation: TsType) => TsOptionalType;
export declare const createTsRestType: (typeAnnotation: TsType) => TsRestType;
export declare const createTsUnionType: (types?: TsType[]) => TsUnionType;
export declare const createTsIntersectionType: (types?: TsType[]) => TsIntersectionType;
export declare const createTsConditionalType: (checkType: TsType, extendsType: TsType, trueType: TsType, falseType: TsType) => TsConditionalType;
export declare const createTsInferType: (typeParam: TsTypeParameter) => TsInferType;
export declare const createTsParenthesizedType: (typeAnnotation: TsType) => TsParenthesizedType;
export declare const createTsTypeOperator: (op: TsTypeOperatorOp, typeAnnotation: TsType) => TsTypeOperator;
export declare const createTsIndexedAccessType: (objectType: TsType, indexType: TsType, readonly?: boolean) => TsIndexedAccessType;
export declare const createTsMappedType: (typeParam: TsTypeParameter, typeAnnotation?: TsType, nameType?: TsType, optional?: TruePlusMinus, readonly?: TruePlusMinus) => TsMappedType;
export declare const createTsLiteralType: (literal: TsLiteral) => TsLiteralType;
export declare const createTsTemplateLiteralType: (types?: TsType[], quasis?: TemplateElement[]) => TsTemplateLiteralType;
export declare const createTsInterfaceDeclaration: (id: Identifier, body: TsInterfaceBody, _extends?: TsExpressionWithTypeArguments[], typeParams?: TsTypeParameterDeclaration, declare?: boolean) => TsInterfaceDeclaration;
export declare const createTsInterfaceBody: (body?: TsTypeElement[]) => TsInterfaceBody;
export declare const createTsExpressionWithTypeArguments: (expression: Expression, typeArguments?: TsTypeParameterInstantiation) => TsExpressionWithTypeArguments;
export declare const createTsTypeAliasDeclaration: (id: Identifier, typeAnnotation: TsType, typeParams?: TsTypeParameterDeclaration, declare?: boolean) => TsTypeAliasDeclaration;
export declare const createTsEnumDeclaration: (id: Identifier, members?: TsEnumMember[], declare?: boolean, isConst?: boolean) => TsEnumDeclaration;
export declare const createTsEnumMember: (id: TsEnumMemberId, init?: Expression) => TsEnumMember;
export declare const createTsModuleDeclaration: (id: TsModuleName, body?: TsNamespaceBody, declare?: boolean, global?: boolean) => TsModuleDeclaration;
export declare const createTsModuleBlock: (body: ModuleItem[]) => TsModuleBlock;
export declare const createTsNamespaceDeclaration: (id: Identifier, body: TsNamespaceBody, declare?: boolean, global?: boolean) => TsNamespaceDeclaration;
export declare const createTsImportEqualsDeclaration: (id: Identifier, moduleRef: TsModuleReference, declare?: boolean, isExport?: boolean, isTypeOnly?: boolean) => TsImportEqualsDeclaration;
export declare const createTsExternalModuleReference: (expression: StringLiteral) => TsExternalModuleReference;
export declare const createTsExportAssignment: (expression: Expression) => TsExportAssignment;
export declare const createTsNamespaceExportDeclaration: (id: Identifier) => TsNamespaceExportDeclaration;
export declare const createTsAsExpression: (expression: Expression, typeAnnotation: TsType) => TsAsExpression;
export declare const createTsInstantiation: (expression: Expression, typeArguments: TsTypeParameterInstantiation) => TsInstantiation;
export declare const createTsTypeAssertion: (expression: Expression, typeAnnotation: TsType) => TsTypeAssertion;
export declare const createTsConstAssertion: (expression: Expression) => TsConstAssertion;
export declare const createTsNonNullExpression: (expression: Expression) => TsNonNullExpression;
export declare const createInvalid: () => {
    type: string;
    span: {
        start: number;
        end: number;
        ctxt: number;
    };
};
